/* Optimized and minified app.js */
(function(){
"use strict";
const $=(s,r=document)=>r.querySelector(s);
const $$=(s,r=document)=>Array.from(r.querySelectorAll(s));

// Debounced scroll handler for performance
let ticking=false;
const onScroll=()=>{
  if(!ticking){
    requestAnimationFrame(()=>{
      const hdr=$('#hdr');
      if(hdr) hdr.classList.toggle('fixed',scrollY>8);
      ticking=false;
    });
    ticking=true;
  }
};
window.addEventListener('scroll',onScroll,{passive:true});

// Throttled pointer move for cursor glow
let glowTicking=false;
const onPointerMove=(e)=>{
  if(!glowTicking){
    requestAnimationFrame(()=>{
      document.documentElement.style.setProperty('--mx',e.clientX+'px');
      document.documentElement.style.setProperty('--my',e.clientY+'px');
      glowTicking=false;
    });
    glowTicking=true;
  }
};
window.addEventListener('pointermove',onPointerMove,{passive:true});

// Optimized parallax with intersection observer
const parallaxElements=$$('.hero-art,[data-parallax]');
if(parallaxElements.length){
  const observer=new IntersectionObserver((entries)=>{
    entries.forEach(entry=>{
      if(entry.isIntersecting){
        const el=entry.target;
        const parallaxValue=Number(el.dataset.parallax||0.2);
        const updateParallax=()=>{
          const rect=el.getBoundingClientRect();
          const t=(rect.top-window.innerHeight*0.5)/window.innerHeight;
          const y=t*(50*parallaxValue);
          el.style.transform=`translate3d(0,${y}px,0)`;
        };
        
        const scrollHandler=()=>requestAnimationFrame(updateParallax);
        window.addEventListener('scroll',scrollHandler,{passive:true});
        window.addEventListener('resize',scrollHandler);
        updateParallax();
      }
    });
  });
  parallaxElements.forEach(el=>observer.observe(el));
}

// Mobile navigation
const navToggle=$('.nav-toggle');
const nav=$('#site-nav');
if(navToggle&&nav){
  navToggle.addEventListener('click',()=>{
    const isOpen=document.body.classList.toggle('nav-open');
    navToggle.setAttribute('aria-expanded',isOpen?'true':'false');
  });
  
  // Close nav on link click or escape
  $$('.nav a').forEach(a=>a.addEventListener('click',()=>{
    document.body.classList.remove('nav-open');
    navToggle.setAttribute('aria-expanded','false');
  }));
  
  document.addEventListener('keydown',(e)=>{
    if(e.key==='Escape'&&document.body.classList.contains('nav-open')){
      document.body.classList.remove('nav-open');
      navToggle.setAttribute('aria-expanded','false');
    }
  });
  
  // Close on outside click
  document.addEventListener('click',(e)=>{
    if(document.body.classList.contains('nav-open')&&
       !nav.contains(e.target)&&e.target!==navToggle){
      document.body.classList.remove('nav-open');
      navToggle.setAttribute('aria-expanded','false');
    }
  },true);
}

// Enhanced radar chart function
window.renderRadar=(svgId,axes,A,B)=>{
  const svg=$('#'+svgId);
  if(!svg) return;
  
  const cx=340,cy=240,r=180;
  const NS=(x)=>document.createElementNS('http://www.w3.org/2000/svg',x);
  const pt=(i,t)=>{
    const ang=(Math.PI*2*i/axes.length)-Math.PI/2;
    return[cx+Math.cos(ang)*r*t,cy+Math.sin(ang)*r*t];
  };
  
  svg.innerHTML='';
  
  // Grid circles
  for(let k=1;k<=4;k++){
    const rr=r*k/4;
    const c=NS('circle');
    c.setAttribute('cx',cx);
    c.setAttribute('cy',cy);
    c.setAttribute('r',rr);
    c.setAttribute('fill','none');
    c.setAttribute('stroke','#1b1d20');
    svg.appendChild(c);
  }
  
  // Axes and labels
  axes.forEach((lab,i)=>{
    const[x,y]=pt(i,1);
    const line=NS('line');
    line.setAttribute('x1',cx);
    line.setAttribute('y1',cy);
    line.setAttribute('x2',x);
    line.setAttribute('y2',y);
    line.setAttribute('stroke','#1b1d20');
    svg.appendChild(line);
    
    const tx=NS('text');
    tx.setAttribute('x',x);
    tx.setAttribute('y',y);
    tx.setAttribute('fill','#a6b1c7');
    tx.setAttribute('font-size','12');
    tx.setAttribute('text-anchor','middle');
    tx.textContent=lab;
    svg.appendChild(tx);
  });
  
  // Data polygons
  const poly=(vals,color)=>{
    const pts=vals.map((v,i)=>pt(i,v)).map(([x,y])=>`${x},${y}`).join(' ');
    const p=NS('polygon');
    p.setAttribute('points',pts);
    p.setAttribute('fill',color);
    p.setAttribute('stroke',color.replace('0.25','1'));
    p.setAttribute('stroke-width','1');
    svg.appendChild(p);
  };
  
  poly(A,'rgba(255,53,85,0.25)');
  poly(B,'rgba(138,43,226,0.25)');
};
})();